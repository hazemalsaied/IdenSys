import os
import operator
from param import FeatParams, XPParams,Paths, PrintParams
from reports import Report


class Corpus:
    """
        a class used to encapsulate all the information of the corpus
    """

    mweTokenDic = {}
    mweDictionary = {}

    def __init__(self, path):
        """
            an initializer of the corpus, responsible of creating a structure of objects encapsulating all the information
            of the corpus, its sentences, tokens and MWEs.

            This function iterate over the lines of corpus document to create the precedent ontology
        :param path: the physical path of the corpus document
        """

        Report.createLanguageFolder()
        self.sentNum, self.mweNum, self.intereavingNum, self.emeddedNum, self.singleWordExp, \
        self.continousExp, self.trainingSents, self.testingSents, self.trainDataSet,mweFile,testBlind  = \
            0, 0, 0, 0, 0, 0, [], [], [], os.path.join(path, 'train.parsemetsv'), os.path.join(path, 'test.blind.parsemetsv')
        conlluFile , testConllu = self.getTrainAndTestConlluPath(path)

        testBlind = os.path.join(path, 'test.blind.parsemetsv')

        if conlluFile is not None and testConllu is not None:
            self.trainDataSet = Corpus.readConlluFile(conlluFile)
            self.mweNum = Corpus.readMweFile(mweFile, self.trainDataSet)
            self.sentNum = len(self.trainDataSet)

            for sent in self.trainDataSet:
                self.emeddedNum += sent.recognizeEmbeddedVMWEs()
                self.intereavingNum += sent.recognizeInterleavingVMWEs()
                x, y = sent.recognizeContinouosandSingleVMWEs()
                self.singleWordExp += x
                self.continousExp += y
            if XPParams.realExper:
                self.testDataSet = Corpus.readConlluFile(testConllu)
        else:
            self.trainDataSet, self.sentNum, self.mweNum = Corpus.readSentences(mweFile)
            self.testDataSet, x, y = Corpus.readSentences(testBlind, forTest=True)
            for sent in self.trainDataSet:
                self.emeddedNum += sent.recognizeEmbeddedVMWEs()
                self.intereavingNum += sent.recognizeInterleavingVMWEs()
                x, y = sent.recognizeContinouosandSingleVMWEs()
                self.singleWordExp += x
                self.continousExp += y
        self.getTrainAndTestSents()


        self.printSentsWithEmbeddedMWEs()


    def getTrainAndTestConlluPath(self,path):
        conlluFile, testConllu = None , None
        if XPParams.useAutoGeneratedPOS and XPParams.useAutoGeneratedDEP and os.path.isfile(
                os.path.join(path, 'train.conllu.autoPOS.autoDep')):
            conlluFile = os.path.join(path, 'train.conllu.autoPOS.autoDep')
            if os.path.isfile(os.path.join(path, 'test.conllu.autoPOS.autoDep')):
                testConllu = os.path.join(path, 'test.conllu.autoPOS.autoDep')
        elif XPParams.useAutoGeneratedPOS and os.path.isfile(os.path.join(path, 'train.conllu.autoPOS')):
            conlluFile = os.path.join(path, 'train.conllu.autoPOS')
            if os.path.isfile(os.path.join(path, 'test.conllu.autoPOS')):
                testConllu = os.path.join(path, 'test.conllu.autoPOS')
        elif os.path.isfile(os.path.join(path, 'train.conllu')):
            conlluFile = os.path.join(path, 'train.conllu')
            if os.path.isfile(os.path.join(path, 'test.conllu')):
                testConllu = os.path.join(path, 'test.conllu')
        return conlluFile, testConllu


    def printSentsWithEmbeddedMWEs(self):
        if not PrintParams.printSentsWithEmbeddedMWEs:
            return
        for sent in self.trainDataSet:
            printSent = False
            for mwe in sent.vMWEs:
                if mwe.isEmbedded:
                    printSent = True
                    break
            if printSent:
                print sent


    @staticmethod
    def readConlluFile(conlluFile):
        sentences = []
        with open(conlluFile) as corpusFile:
            # Read the corpus file
            lines = corpusFile.readlines()
            sent = None
            senIdx = 0
            sentId = ''

            lineNum = 0
            missedUnTag = 0
            missedExTag = 0

            for line in lines:
                if len(line) > 0 and line.endswith('\n'):
                    line = line[:-1]
                if line.startswith('# sentid:'):
                    sentId = line.split('# sentid:')[1].strip()


                elif line.startswith('# sentence-text:'):
                    continue

                elif line.startswith('1\t'):
                    if sentId.strip() != '':
                        sent = Sentence(senIdx, sentid=sentId)
                    else:
                        sent = Sentence(senIdx)
                    senIdx += 1
                    sentences.append(sent)

                if not line.startswith('#'):
                    lineParts = line.split('\t')

                    if len(lineParts) != 10 or '-' in lineParts[0]:
                        continue

                    lineNum += 1
                    if lineParts[3] == '_':
                        missedUnTag += 1
                    if lineParts[4] == '_':
                        missedExTag += 1

                    morpho = ''
                    if lineParts[5] != '_':
                        morpho = lineParts[5].split('|')
                    if lineParts[6] != '_':
                        token = Token(lineParts[0], lineParts[1].lower(), lemma=lineParts[2],
                                      abstractPosTag=lineParts[3], morphologicalInfo=morpho,
                                      dependencyParent=int(lineParts[6]),
                                      dependencyLabel=lineParts[7])
                    else:
                        token = Token(lineParts[0], lineParts[1].lower(), lemma=lineParts[2],
                                      abstractPosTag=lineParts[3], morphologicalInfo=morpho,
                                      dependencyLabel=lineParts[7])
                    if XPParams.useUniversalPOSTag:
                        token.posTag = lineParts[3]
                    else:
                        if lineParts[4] != '_':
                            token.posTag = lineParts[4]
                        else:
                            token.posTag = lineParts[3]
                    # Associate the token with the sentence
                    sent.tokens.append(token)
                    sent.text += token.text + ' '
        return sentences

    @staticmethod
    def readMweFile(mweFile, sentences):
        mweNum = 0
        with open(mweFile) as corpusFile:

            # Read the corpus file
            lines = corpusFile.readlines()
            noSentToAssign = False
            sentIdx = 0
            for line in lines:
                if line == '\n' or line.startswith('# sentence-text:') or (
                            line.startswith('# sentid:') and noSentToAssign):
                    continue
                if len(line) > 0 and line.endswith('\n'):
                    line = line[:-1]
                if line.startswith('1\t'):
                    sent = sentences[sentIdx]
                    sentIdx += 1
                lineParts = line.split('\t')
                if '-' in lineParts[0]:
                    continue
                if lineParts is not None and len(lineParts) == 4 and lineParts[3] != '_':

                    token = sent.tokens[int(lineParts[0]) - 1]
                    vMWEids = lineParts[3].split(';')
                    for vMWEid in vMWEids:
                        id = int(vMWEid.split(':')[0])
                        # New MWE captured
                        if id not in sent.getWMWEIds():
                            if len(vMWEid.split(':')) > 1:
                                type = str(vMWEid.split(':')[1])
                                vMWE = VMWE(id, token, type)
                            else:
                                vMWE = VMWE(id, token)
                            mweNum += 1
                            sent.vMWEs.append(vMWE)
                        # Another token of an under-processing MWE
                        else:
                            vMWE = sent.getVMWE(id)
                            if vMWE is not None:
                                vMWE.addToken(token)
                        # associate the token with the MWE
                        token.setParent(vMWE)
        return mweNum

    @staticmethod
    def readSentences(mweFile, forTest=False):
        sentences = []
        sentNum, mweNum = 0, 0
        with open(mweFile) as corpusFile:
            # Read the corpus file
            lines = corpusFile.readlines()
            sent = None
            senIdx = 1
            for line in lines:
                if len(line) > 0 and line.endswith('\n'):
                    line = line[:-1]
                if line.startswith('1\t'):
                    # sentId = line.split('# sentid:')[1]
                    if sent is not None:
                        # Represent the sentence as a sequece of tokens and POS tags
                        sent.setTextandPOS()
                        if not forTest:
                            sent.recognizeEmbeddedVMWEs()
                            sent.recognizeInterleavingVMWEs()

                    sent = Sentence(senIdx)
                    senIdx += 1
                    sentences.append(sent)

                elif line.startswith('# sentence-text:'):
                    sentText = ''
                    if len(line.split(':')) > 1:
                        sent.text = line.split('# sentence-text:')[1]

                lineParts = line.split('\t')

                # Empty line or lines of the form: "8-9	can't	_	_"
                if len(lineParts) != 4 or '-' in lineParts[0]:
                    continue
                token = Token(lineParts[0], lineParts[1])
                # Trait the MWE
                if not forTest and lineParts[3] != '_':
                    vMWEids = lineParts[3].split(';')
                    for vMWEid in vMWEids:
                        id = int(vMWEid.split(':')[0])
                        # New MWE captured
                        if id not in sent.getWMWEIds():
                            type = str(vMWEid.split(':')[1])
                            vMWE = VMWE(id, token, type)
                            mweNum += 1
                            sent.vMWEs.append(vMWE)
                        # Another token of an under-processing MWE
                        else:
                            vMWE = sent.getVMWE(id)
                            if vMWE is not None:
                                vMWE.addToken(token)
                        # associate the token with the MWE
                        token.setParent(vMWE)
                # Associate the token with the sentence
                sent.tokens.append(token)
            sentNum = len(sentences)
            return sentences, sentNum, mweNum

    @staticmethod
    def getMWEDic(trainingSents):
        mweTokenDictionary = {}
        mweDictionary = {}
        for sent in trainingSents:
            for mwe in sent.vMWEs:
                if mwe.getLemmaString() in mweDictionary.keys():
                    mweDictionary[mwe.getLemmaString()] += 1
                    for token in mwe.tokens:
                        if token.lemma.strip() != '':
                            mweTokenDictionary[token.lemma] = 1
                        else:
                            mweTokenDictionary[token.text] = 1
                else:
                    mweDictionary[mwe.getLemmaString()] = 1
                    for token in mwe.tokens:
                        if token.lemma.strip() != '':
                            mweTokenDictionary[token.lemma] = 1
                        else:
                            mweTokenDictionary[token.text] = 1
        if FeatParams.usePreciseDictionary:
            for key1 in mweDictionary.keys():
                for key2 in mweDictionary.keys():
                    if key1 != key2:
                        if key1 in key2:
                            mweDictionary.pop(key1, None)
                        elif key2 in key1:
                            mweDictionary.pop(key2, None)
        path = os.path.join(Paths.iterationPath, 'dic.txt')
        if not XPParams.useCrossValidation and PrintParams.createDictionary:
            Report.createMWELexic(mweDictionary, path)
        return mweDictionary, mweTokenDictionary

    @staticmethod
    def initializeSents(sents):
        # Erasing each effect of the previous iteration
        for sent in sents:
            sent.identifiedVMWEs = []
            sent.initialTransition = None
            sent.featuresInfo = []
            for mwe in sent.vMWEs:
                mwe.isInTrainingCorpus = 0

    def getTrainAndTestSents(self):

        if XPParams.realExper:
            self.trainingSents = self.trainDataSet
            self.testingSents = self.testDataSet

        if XPParams.useCrossValidation:
            return [], []

        if len(self.trainingSents) <= 0:
            idx = 0
            self.trainingSents, self.testingSents = [], []
            for sent in self.trainDataSet:
                if idx % 5 == 0:
                    self.testingSents.append(sent)
                else:
                    self.trainingSents.append(sent)
                idx += 1

        return self.trainingSents, self.testingSents

    @staticmethod
    def getRangs(sents):

        testNum = int(len(sents) * 0.2)
        testRanges = [[0, testNum], [testNum, 2 * testNum], [2 * testNum, 3 * testNum], [3 * testNum, 4 * testNum],
                      [4 * testNum, len(sents)]]

        trainRanges = [[testNum, len(sents)], [0, testNum, 2 * testNum, len(sents)],
                       [0, 2 * testNum, 3 * testNum, len(sents)], [0, 3 * testNum, 4 * testNum, len(sents)],
                       [0, 4 * testNum]]

        return [testRanges, trainRanges]

    def divideSents(self, testing, training, x):

        self.testingSents = self.trainDataSet[testing[x][0]: testing[x][1]]
        if len(training[x]) == 2:
            self.trainingSents = self.trainDataSet[training[x][0]: training[x][1]]
        else:
            self.trainingSents = self.trainDataSet[training[x][0]: training[x][1]] + \
                                 self.trainDataSet[training[x][2]: training[x][3]]

    @staticmethod
    def getNewIdentifiedMWE(testingSents):

        idenMWEs = 0
        newIdenMWEs = 0
        semiNewIdenMWEs = 0
        for sent in testingSents:
            for mwe in sent.vMWEs:
                if mwe.getLemmaString() not in Corpus.mweDictionary.keys():
                    idenMWEs += 1
            for mwe in sent.identifiedVMWEs:
                if mwe.getLemmaString() not in Corpus.mweDictionary.keys():
                    for vmw1 in sent.vMWEs:
                        if vmw1.getLemmaString() == mwe.getLemmaString():
                            newIdenMWEs += 1
                            break
                elif mwe.getLemmaString() in Corpus.mweDictionary.keys() and \
                                Corpus.mweDictionary[mwe.getLemmaString()] < 5:
                    semiNewIdenMWEs += 1

        return float(newIdenMWEs) / idenMWEs, float(semiNewIdenMWEs) / idenMWEs

class Sentence:
    """
       a class used to encapsulate all the information of a sentence
    """

    def __init__(self, id, sentid=''):

        self.sentid = sentid
        self.id = id
        self.tokens = []
        self.vMWEs = []
        self.identifiedVMWEs = []
        self.text = ''
        self.initialTransition = None
        self.featuresInfo = []


    def getWMWEs(self):
        return self.vMWEs

    def getWMWEIds(self):
        result = []
        for vMWE in self.vMWEs:
            result.append(vMWE.getId())
        return result

    def getVMWE(self, id):

        for vMWE in self.vMWEs:
            if vMWE.getId() == int(id):
                return vMWE
        return None

    def setTextandPOS(self):

        tokensTextList = []
        for token in self.tokens:
            self.text += token.text + ' '
            tokensTextList.append(token.text)
        self.text = self.text.strip()

    def recognizeEmbeddedVMWEs(self):
        if len(self.vMWEs) <= 1:
            return 0
        result = 0
        traitedPairs = []
        for vMwe1 in self.vMWEs:
            for vMwe2 in self.vMWEs:
                if vMwe1 is not vMwe2:
                    isTraited = False
                    for pair in traitedPairs:
                        if vMwe1 in pair and vMwe2 in pair:
                            isTraited = True
                    if not isTraited:
                        traitedPairs.append([vMwe1, vMwe2])
                        # Get The longer VMWE
                        masterVmwe = vMwe1
                        slaveVmwe = vMwe2
                        if len(vMwe2.tokens) > len(vMwe2.tokens):
                            masterVmwe = vMwe2
                            slaveVmwe = vMwe1
                        slaveVmwe.isEmbedded = True
                        for token in slaveVmwe.tokens:
                            if masterVmwe not in token.parentMWEs:
                                slaveVmwe.isEmbedded = False
                        if slaveVmwe.isEmbedded:
                            slaveVmwe.directParent = masterVmwe
                            result += 1
        self.getDirectParents()
        return result

    def recognizeContinouosandSingleVMWEs(self):
        singleWordExp, continousExp = 0, 0
        for mwe in self.vMWEs:
            if len(mwe.tokens) == 1:
                mwe.isSingleWordExp = True
                mwe.isContinousExp = True
                singleWordExp += 1
                continousExp += 1
            else:
                if self.isContinousMwe(mwe):
                    continousExp += 1
        return singleWordExp, continousExp

    def isContinousMwe(self, mwe):
        idxs = []
        for token in mwe.tokens:
            idxs.append(self.tokens.index(token))
        range = xrange(min(idxs), max(idxs))
        mwe.isContinousExp = True
        for i in range:
            if i not in idxs:
                mwe.isContinousExp = False
        return mwe.isContinousExp

    def recognizeInterleavingVMWEs(self):
        if len(self.vMWEs) <= 1:
            return 0
        result = 0
        for vmwe in self.vMWEs:
            if vmwe.isEmbedded or vmwe.isInterleaving:
                continue
            for token in vmwe.tokens:
                if len(token.parentMWEs) > 1:
                    for parent in token.parentMWEs:
                        if parent is not vmwe:
                            if parent.isEmbedded:
                                continue
                            parents = sorted(token.parentMWEs, key=lambda VMWE: VMWE.id)
                            if parent != parents[0]:
                                parent.isInterleaving = True
                                result += 1
        return result

    def getCorpusText(self, gold=True):
        if gold:
            mwes = self.vMWEs
        else:
            mwes = self.identifiedVMWEs
        lines = ''
        idx = 1
        for token in self.tokens:
            line = str(idx) + '\t' + token.text + '\t_\t'
            idx += 1
            for mwe in mwes:
                if token in mwe.tokens:
                    if line.endswith('\t'):
                        line += str(mwe.id)
                    else:
                        line += ';' + str(mwe.id)
            if line.endswith('\t'):
                line += '_'
            lines += line + '\n'
        return lines

    def getCorpusTextWithPlus(self):
        goldMwes = self.vMWEs
        predMwes = self.identifiedVMWEs
        lines = ''
        idx = 1
        for token in self.tokens:
            line = str(idx) + '\t' + token.text + '\t_\t'
            idx += 1
            for mwe in goldMwes:
                if token in mwe.tokens:
                    if line.endswith('\t'):
                        line += '+'
                        break

            if line.endswith('\t'):
                line += '_\t'
            else:
                line += '\t'
            for mwe in predMwes:
                if token in mwe.tokens:
                    if line.endswith('\t'):
                        line += '+'
                        break
            if line.endswith('\t'):
                line += '_'
            lines += line + '\n'
        return lines

    def isPrintable(self):

        if not PrintParams.printSentsWithEmbeddedMWEs:
            return
        for mwe in self.vMWEs:
            if mwe.isEmbedded:
                return True
        return False



        # if PrintParams.printSentsWithEmbeddedMWEs and len(self.vMWEs) > 2:
        #     for mwe in self.vMWEs:
        #         if mwe.isEmbedded:
        #             return True
        # return False

    def getDirectParents(self):


        for token in self.tokens:
            token.getDirectParent()


    @staticmethod
    def getTokens(elemlist):
        if isinstance(elemlist, Token):
            return [elemlist]
        result = []
        for elem in elemlist:
            if isinstance(elem, Token):
                result.append(elem)
            elif isinstance(elem, list):
                result.extend(Sentence.getTokens(elem))
        return result

    @staticmethod
    def getTokenLemmas(tokens):
        text = ''
        tokens = Sentence.getTokens(tokens)
        for token in tokens:
            if token.lemma != '':
                text += token.lemma + ' '
            else:
                text += token.text + ' '
        return text.strip()

    def printSummary(self):
        vMWEText = ''
        for vMWE in self.vMWEs:
            vMWEText += str(vMWE) + '\n'
        if len(self.identifiedVMWEs) > 0:
            identifiedMWE = '### Identified MWEs: \n'
            for mwe in self.identifiedVMWEs:
                identifiedMWE += str(mwe) + '\n'
        else:
            identifiedMWE = ''

        return '## Sentence No. ' + str(self.id) + ' - ' + self.sentid + '\n' + self.text + \
               '\n### Existing MWEs: \n' + vMWEText + identifiedMWE

    def __str__(self):

        vMWEText = ''
        for vMWE in self.vMWEs:
            vMWEText += str(vMWE) + '\n\n'
        if len(self.identifiedVMWEs) > 0:
            identifiedMWE = '### Identified MWEs: \n'
            for mwe in self.identifiedVMWEs:
                identifiedMWE += str(mwe) + '\n\n'
        else:
            identifiedMWE = ''
        featuresInfo = ''

        result = ''
        transition = self.initialTransition
        idx = 0
        while True:
            type = ''
            configuration = ''
            if transition is not None:
                if transition.type is not None:
                    type = transition.type.name
                else:
                    type = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
                configuration = str(transition.configuration)
                if type.startswith('MERGE') :
                    type = '**'+type+'**&nbsp;&nbsp;&nbsp;'
                if len(type) == 'SHIFT':
                    type = type + '&nbsp;&nbsp;&nbsp;'
                result += '\n\n' + str(
                    transition.id) + '- ' + type + '&nbsp;&nbsp;&nbsp;' + '>' + '&nbsp;&nbsp;&nbsp;' + configuration + '\n\n'
                if transition.next is None:
                    break
                transition = transition.next
                if PrintParams.printFeaturesOfSent and  len(self.featuresInfo) == 2 and len(self.featuresInfo[1]) > 0:
                    sortedDic = sorted(self.featuresInfo[1][idx].items(), key=operator.itemgetter(0))
                    for item in sortedDic:
                        result += str(item[0]) + ': ' + str(item[1]) + ', '
                idx += 1
            else:  # result += str(self.featuresInfo[1][idx]) + '\n\n'
                break
        text = ''
        for token in self.tokens:
            if token.parentMWEs is not None and len(token.parentMWEs)> 0:
                text+= '**' + token.text + '**' + ' '
            else: text+=  token.text +  ' '

        return '## Sentence No. ' + str(self.id) + ' - ' + self.sentid + '\n' + text + \
               '\n### Existing MWEs: \n' + vMWEText + identifiedMWE \
               + '\n' + result # + str(self.initialTransition) + '\n### Features: \n' + featuresInfo

class VMWE:
    """
        A class used to encapsulate the information of a verbal multi-word expression
    """

    def __init__(self, id, token=None, type='', isEmbedded=False, isInterleaving=False, isInTrainingCorpus=0):
        self.id = int(id)
        self.isInTrainingCorpus = isInTrainingCorpus
        self.tokens = []
        self.isSingleWordExp = False
        self.isContinousExp = False
        if token is not None:
            self.tokens.append(token)
        self.type = type
        self.isEmbedded = isEmbedded
        self.isInterleaving = isInterleaving
        self.isVerbal = True
        self.directParent = None

    def getId(self):
        return self.id

    def addToken(self, token):
        self.tokens.append(token)

    @staticmethod
    def getVMWENumber(tokens):
        result = 0
        for token in tokens:
            if isinstance(token, VMWE):
                result += 1
        return result

    @staticmethod
    def haveSameParents(tokens):
        hasParent = True
        # Do they have all a parent?
        for token in tokens:
            if len(token.parentMWEs) == 0:
                return False
        # Get all parents of tokens
        parents = []
        for token in tokens:
            for parent in token.parentMWEs:
                if parent not in parents:
                    parents.append(parent)
        selectedParents = list(parents)
        for parent in list(parents):
            for token in tokens:
                if parent not in token.parentMWEs:
                    if parent in selectedParents:
                        selectedParents.remove(parent)
        if len(selectedParents) >= 1:
            return True
        return False

    @staticmethod
    def haveSameDirectParents(s0, s1):
        if isinstance(s0, Token) and isinstance(s1, Token):
            return s0.directParent == s1.directParent
        #if isinstance(s0, list):


    @staticmethod
    def getSharedVMWEs(tokens):
        hasParent = True
        # Do they have all a parent?
        for token in tokens:
            if len(token.parentMWEs) == 0:
                hasParent = False
                break
        if hasParent:
            # Get all parents of tokens
            parents = []
            for token in tokens:
                for parent in token.parentMWEs:
                    if parent not in parents:
                        parents.append(parent)
            selectedParents = list(parents)
            for parent in list(parents):
                if len(parent.tokens) != len(tokens):
                    if parent in selectedParents:
                        selectedParents.remove(parent)
                    continue
                for token in tokens:
                    if parent not in token.parentMWEs:
                        if parent in selectedParents:
                            selectedParents.remove(parent)
            return selectedParents
        return None

    # def getDirectParent(self):
    #     self.directParent = None
    #     if self.parentMWEs is not None and len(self.parentMWEs)> 0:
    #         if len(self.parentMWEs) == 1:
    #             self.directParent = self.parentMWEs[0]
    #         else:
    #             parents = sorted(self.parentMWEs, key=lambda VMWE : (VMWE.isInterleaving, VMWE.isEmbedded, len(VMWE.tokens) ))
    #             for parent in parents:
    #                 if not parent.isInterleaving:
    #                     self.directParent = parent
    #                     break
    #     return self.directParent

    def __str__(self):
        tokensStr = ''
        for token in self.tokens:
            tokensStr += token.text + ' '
        tokensStr = tokensStr.strip()
        isInterleaving = ''
        if self.isInterleaving:
            isInterleaving = ', Interleaving '
        isEmbedded = ''
        if self.isEmbedded:
            isEmbedded = ', Embedded'
            # isContinousExp =''
            # if self.isContinousExp:
            # isContinousExp = 'Continous'
        inTrainingCorpus = ''
        if self.isInTrainingCorpus != 0:
            inTrainingCorpus = ', ' + str(self.isInTrainingCorpus)
        type = ''
        if self.type != '':
            type = '(' + self.type
            if self.isInTrainingCorpus != 0:
                type += ', ' + str(self.isInTrainingCorpus) + ')'
            else:
                type += ')'
        tokenText = 'Tokens : \n'
        for token in self.tokens:
            tokenText += token.text + '\n' # ' parent: ' + str(token.directParent.id) + '\n'
        return str(self.id) + '- ' + '**' + tokensStr + '** ' + type + isEmbedded + isInterleaving + tokenText

    def getString(self):
        result = ''
        for token in self.tokens:
            result += token.text + ' '
        return result[:-1]

    def getLemmaString(self):
        result = ''
        for token in self.tokens:
            if token.lemma.strip() != '':
                result += token.lemma + ' '
            else:
                result += token.text + ' '
        return result[:-1]

    def In(self, vmwes):

        for vmwe in vmwes:
            if vmwe.getString() == self.getString():
                return True

        return False



class Token:
    """
        a class used to encapsulate all the information of a sentence tokens
    """

    def __init__(self, position, txt, lemma='', posTag='', abstractPosTag='', morphologicalInfo=[], dependencyParent=-1,
                 dependencyLabel=''):
        self.position = int(position)
        self.text = txt
        self.lemma = lemma
        self.abstractPosTag = abstractPosTag
        self.posTag = posTag
        self.morphologicalInfo = morphologicalInfo
        self.dependencyParent = dependencyParent
        self.dependencyLabel = dependencyLabel
        self.parentMWEs = []
        self.directParent = None

    def setParent(self, vMWE):
        self.parentMWEs.append(vMWE)

    def getLemma(self):
        if self.lemma != '':
            return self.lemma.strip()
        return self.text.strip()

    def getDirectParent(self):
        self.directParent = None
        if self.parentMWEs is not None and len(self.parentMWEs)> 0:
            if len(self.parentMWEs) == 1:
                if not self.parentMWEs[0].isInterleaving:
                    self.directParent = self.parentMWEs[0]
            else:
                parents = sorted(self.parentMWEs, key=lambda VMWE : (VMWE.isInterleaving, VMWE.isEmbedded, len(VMWE.tokens) ), reverse=True)
                for parent in parents:
                    if not parent.isInterleaving:
                        self.directParent = parent
                        break
        return self.directParent

    def In(self, vmwe):
        for token in vmwe.tokens:
            if token.text.lower() == self.text.lower() and token.position == self.position:
                return True
        return False

    def __str__(self):
        parentTxt = ''
        if len(self.parentMWEs) != 0:
            for parent in self.parentMWEs:
                parentTxt += str(parent) + '\n'

        return str(self.position) + ' : ' + self.text + ' : ' + self.posTag + '\n' + 'parent VMWEs\n' + parentTxt



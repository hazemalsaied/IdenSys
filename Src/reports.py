import logging
import operator
import os
from param import XPParams, Paths, PrintParams

annotationReport = ''
onlineTrainingProblems = ''

def printLangAnalysis(corpus):
    path = os.path.join(Paths.rootResultFolder, 'langAnalysis.csv')
    titles, values, titleLine, valueLine, valueLines = [], [], '', '', ''

    titles.append('Lang')
    values.append(Paths.languageName)

    getLangDetails(corpus, titles, values)

    for elem in values:
        valueLine += str(elem) + ','
    valueLine = valueLine[:-1] + '\n'
    valueLines += valueLine

    mode = "a"
    if not os.path.exists(path):
        mode = "w+"
        for elem in titles:
            titleLine += str(elem) + ','
        titleLine = titleLine[:-1] + '\n'
        valueLines = titleLine + valueLines
    with open(path, mode) as totalResultFile:
        totalResultFile.write(valueLines)

def createRootResultFolder():
    XPParams.printState()
    initialValue = Paths.rootResultFolder

    if XPParams.experimental:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'tmp')

    if XPParams.baseline:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'Baseline')
    elif  not XPParams.useAutoGeneratedDEP and not XPParams.useAutoGeneratedPOS:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'Gold')
    elif XPParams.useAutoGeneratedDEP and  XPParams.useAutoGeneratedPOS:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'Auto')

    if XPParams.useCrossValidation:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'CV')
    else:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'TestDataSet')

    if XPParams.useDynamicOracle:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'DynamicOracle')
    elif XPParams.includeEmbedding:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'Embedding')
    else:
        Paths.rootResultFolder = os.path.join(Paths.rootResultFolder, 'FirstVersion')
    logging.warn('Root Result Folder: ' + Paths.rootResultFolder)
    if initialValue == Paths.rootResultFolder:
        raise Exception('Hazem : Contradictory parameters!')
    if not os.path.exists(Paths.rootResultFolder):
        os.makedirs(Paths.rootResultFolder)

def createLanguageFolder(langName):
    Paths.languageName = langName
    Paths.langResultFolder = os.path.join(Paths.rootResultFolder, Paths.languageName)
    Paths.iterationPath = Paths.langResultFolder
    if not os.path.exists(Paths.langResultFolder):
        os.makedirs(Paths.langResultFolder)

def createMWELexic(dic, path=os.path.join(Paths.iterationPath, 'Dictionary.md')):
    if PrintParams.printReport:
        sortedDic = sorted(dic.items(), key=operator.itemgetter(1), reverse=True)

        result = ''
        for item in sortedDic:
            result += str(item[0]) + ': ' + str(item[1]) + '\n\n'
        dicFile = open(path, 'w')
        dicFile.write(result)

def editReadme(mode, text):
    printingPath = os.path.join(Paths.iterationPath, 'Readme.md')
    staticParsingFile = open(printingPath, mode)
    staticParsingFile.write(text)

def createStaticParsingReports(sents):
    if not PrintParams.printReport:
        return
    sentsForPrinting = [s for s in sents if len(s.vMWEs) >= 2]
    sentsForPrinting = sorted(sentsForPrinting, key=lambda Sentence: len(Sentence.vMWEs), reverse=True)
    sentsForPrinting = sentsForPrinting[0:5]
    printingPath = os.path.join(Paths.iterationPath, 'StaticParsing.md')
    staticParsingFile = open(printingPath, 'w')
    result = ''
    for sent in sentsForPrinting:
        result += str(sent)
    staticParsingFile.write(result)

def createEmbeddingSentsReports(sents, crossValidationIdx=''):
    sentsForPrinting = [s for s in sents if isEmbeddedSent(s)]

    sentsForPrinting = sorted(sentsForPrinting, key=lambda Sentence: len(Sentence.vMWEs), reverse=True)
    printingPath = os.path.join(Paths.iterationPath, 'EmbeddedSents' + str(crossValidationIdx) + '.md')
    staticParsingFile = open(printingPath, 'w')
    result = ''
    for sent in sentsForPrinting:
        result += str(sent)
    staticParsingFile.write(result)

def isEmbeddedSent(sent):
    for mwe in sent.vMWEs:
        if mwe.isEmbedded or mwe.isInterleaving:
            return True
    return False

def getEmbeddedSents(corpus):
    report = '# emeddedNum = '
    report += str(corpus.emeddedNum) + '\n'
    idx  = 0
    for sent in corpus.trainingSents:
        if sent.containsEmbedding:
            idx += 1
            report += '# Sent' + str(idx) + '\n'
            report += sent.text  + '\n'
            report += '### MWES: '
            for vme in sent.vMWEs:
                report += vme.getString() + '\n'
                if vme.isEmbedded:
                    report += '**Embedded**' + '\n'
            report += '### Identified MWES: '
            for vme in sent.identifiedVMWEs:
                report += vme.getString()  + '\n'
                if vme.isEmbedded:
                    report += '**Embedded**' + '\n'
    oracleErrorFilePath = os.path.join(Paths.iterationPath, 'EmbeddedSent.md')
    with open(oracleErrorFilePath, 'w') as oracleErrorFile:
        oracleErrorFile.write(report)

def createOracleErrorsReport(corpus):
    report, sentNum = '', 0

    for sent in corpus.trainingSents:
        if sent.blackMergeNum != len(sent.vMWEs) and not sent.withRandomSelection:
            if (XPParams.includeEmbedding and sent.blackMergeNum != (
                     len(sent.vMWEs) - sent.interleavingNum - sent.distributedEmbeddingNum)) or \
                    (not XPParams.includeEmbedding and sent.blackMergeNum != (
                            len(sent.vMWEs) - sent.interleavingNum - sent.embeddedNum)):
                report += '#Oracle problem' + '\n' + str(sent)
                sentNum +=1
    if report != '':
        logging.warn('Oracle is not working well, '+  str(sentNum) +'phrases are not parsed correctly')
        oracleErrorFilePath = os.path.join(Paths.iterationPath, 'OracleError.md')
        with open(oracleErrorFilePath, 'w') as oracleErrorFile:
            oracleErrorFile.write(report)

def creatOnlineTrainingReport():
    if onlineTrainingProblems == '':
        return
    p = os.path.join(Paths.iterationPath, 'OnlineTrainingReport.md')
    with open(p, 'w') as f:
        f.write(onlineTrainingProblems)

def createParsingReport(testingSents, mweDictionary):

    if not PrintParams.printReport:
        return

    # Adding the source of MWE
    for sent in testingSents:
        for mwe in sent.vMWEs:
            if mwe.getLemmaString() in mweDictionary.keys():
                mwe.isInTrainingCorpus = mweDictionary[mwe.getLemmaString()]

    sentsForPrinting = [s for s in testingSents if len(s.vMWEs) >= 1]

    result = ''
    sentsForPrinting = sorted(sentsForPrinting, key=lambda Sentence: len(Sentence.vMWEs), reverse=True)
    printingPath = os.path.join(Paths.iterationPath, 'Parsing.md')
    parsingFile = open(printingPath, 'w')

    for sent in sentsForPrinting[0:5]:
        result += str(sent)
    parsingFile.write(result)

    # Producing a long report
    printingPath = os.path.join(Paths.iterationPath, 'Parsing-long.md')
    parsingFile = open(printingPath, 'w')
    result = ''
    for sent in sentsForPrinting:
        result += sent.printSummary()
    parsingFile.write(result)

def editTotalReadMe(scores, corpus, detailed=False):

    path = os.path.join(Paths.rootResultFolder, 'results.csv')
    titles, values, titleLine, valueLine, valueLines = [], [], '', '', ''

    for idx in range(len(scores) / 3):
        if idx > 0 and not detailed:
            continue
        values, valueLine = [], ''

        titles.append('Lang')
        if idx == 0 :
            values.append(Paths.languageName)
        elif idx == 1:
            values.append('CAT')
        elif  idx == 2:
            values.append('EMB')
        else:
            values.append('MWT')

        fscore = scores[idx * 3]
        recall = scores[idx * 3 + 1]
        precision = scores[idx * 3 + 2]
        titles.append('Fscor')
        values.append(fscore)

        titles.append('Recall')
        values.append(recall)

        titles.append('precision')
        values.append(precision)

        if detailed:
            getLangDetails(corpus, titles, values)
        if values[1] != 0 and values[2] != 0 and values[3] != 0 :
            for elem in values:
                if isinstance(elem, float):
                    valueLine += str("%.3f" % elem) + ','
                else:
                    valueLine += str(elem) + ','
            valueLine = valueLine[:-1] + '\n'
            valueLines += valueLine
        if idx == 0:
            for elem in titles:
                titleLine += str(elem) + ','
            titleLine = titleLine[:-1] + '\n'

    mode = "a"
    if not os.path.exists(path):
        mode = "w+"
        valueLines = titleLine + valueLines
    with open(path, mode) as totalResultFile:
        totalResultFile.write(valueLines)


def getLangDetails(corpus, titles, values):

    titles.append('sentNum')
    values.append(corpus.sentNum)
    titles.append('mweNum')
    values.append(corpus.mweNum)
    titles.append('continousExp')
    values.append(corpus.continousExp)
    titles.append('intereavingNum')
    values.append(corpus.intereavingNum)
    titles.append('singleWordExp')
    values.append(corpus.singleWordExp)
    titles.append('emeddedNum')
    values.append(corpus.emeddedNum)

def createEvaluationFiles(sents):
    if not XPParams.useCrossValidation:
        if not XPParams.realExper:
            goldCorpus = ''
            for sent in sents:
                goldCorpus += sent.getCorpusText() + '\n'
            path = os.path.join(Paths.iterationPath, 'gold.txt')
            wFile = open(path, 'w')
            wFile.write(goldCorpus)

        predCorpus = ''
        for sent in sents:
            predCorpus += sent.getCorpusText(gold=False) + '\n'
        if XPParams.realExper:
            path = os.path.join(Paths.iterationPath, 'test.system.parsemetsv')
        else:
            path = os.path.join(Paths.iterationPath, 'pred.txt')
        wFile = open(path, 'w')
        wFile.write(predCorpus)
